name: Generate Project Issues Report

on:
  workflow_dispatch: # Allows manual triggering
    inputs:
      project_node_id:
        description: 'The Node ID of the ProjectV2 board (e.g., PVT_...)'
        required: true
        type: string
      output_filename:
        description: 'Filename for the CSV report (e.g., report.csv)'
        required: false
        type: string
        default: 'project_issues_report.csv'

jobs:
  build-report:
    runs-on: ubuntu-latest
    permissions:
      contents: read # Needed for checkout
      # No explicit project permissions here, relies on PAT
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Fetch Project Data via GraphQL
        id: fetch_data
        env:
          # Use a Classic PAT stored as a secret. Needs 'repo' and 'project' scopes.
          GH_TOKEN: ${{ secrets.GH_PAT_PROJECTS }}
          PROJECT_ID: ${{ inputs.project_node_id }}
        run: |
          echo "Attempting to fetch data for Project ID: $PROJECT_ID"
          # Store the full GraphQL query in a variable
          read -r -d '' query << EOF
          query GetProjectItemsAndIssueDetails(\$projectId: ID!) {
            node(id: \$projectId) {
              ... on ProjectV2 {
                id
                title
                number
                items(first: 100) { # Adjust 'first' or implement pagination if needed
                  nodes {
                    id
                    fieldValues(first: 20) {
                      nodes {
                        ... on ProjectV2ItemFieldTextValue { text field { ... on ProjectV2Field { name id } } }
                        ... on ProjectV2ItemFieldDateValue { date field { ... on ProjectV2Field { name id } } }
                        ... on ProjectV2ItemFieldNumberValue { number field { ... on ProjectV2Field { name id } } }
                        ... on ProjectV2ItemFieldSingleSelectValue { name optionId field { ... on ProjectV2SingleSelectField { name id } } }
                        ... on ProjectV2ItemFieldIterationValue { title startDate duration iterationId field { ... on ProjectV2IterationField { name id } } }
                      }
                    }
                    content {
                      ... on Issue {
                        id
                        number
                        title
                        state
                        createdAt
                        updatedAt
                        closedAt
                        url
                        author { login }
                        assignees(first: 10) { nodes { login } }
                        labels(first: 20) { nodes { name color } }
                        milestone { title number state }
                        issueType { name } # Kept for future use
                        parent {
                          ... on Issue { title number url id issueType { name } }
                        }
                        repository { nameWithOwner }
                      }
                      # Add other content types if needed (e.g., DraftIssue, PullRequest)
                      # ... on DraftIssue { id title body }
                      # ... on PullRequest { id number title state url repository { nameWithOwner } }
                    }
                  }
                  pageInfo { endCursor hasNextPage }
                }
              }
            }
          }
          EOF

          # Execute the query, save to file, and handle gh command failure
          echo "Executing GraphQL query..."
          gh api graphql -F projectId="$PROJECT_ID" -f query="$query" > project_data.json || {
            echo "ERROR: 'gh api graphql' command failed. API Response was:"
            cat project_data.json # Print the raw response (likely contains API error)
            exit 1 # Exit the script with failure status
          }

          echo "GraphQL query command succeeded. Response saved to project_data.json. Checking content..."

          # Check if the expected data structure exists in the response using refined jq check
          if ! jq -e '.data.node // empty' project_data.json > /dev/null; then
            echo "ERROR: '.data.node' not found in the GraphQL response, or response was empty/invalid."
            echo "--- Start of project_data.json content ---"
            jq . project_data.json # Print the JSON response for debugging
            echo "--- End of project_data.json content ---"
            exit 1 # Exit the script with failure status
          fi

          echo "Successfully fetched and validated project data."

      - name: Process Data and Generate CSV
        id: generate_csv
        run: |
          # Define CSV Header
          header='"Issue Number","Issue Title","State","Repository","URL","Created At","Updated At","Closed At","Author","Assignees","Labels","Milestone","Issue Type","Parent Issue #","Parent Issue Title","Project Sprint","Project Status","Project Team"'

          # Use jq to transform JSON to CSV rows, handling potential nulls
          # Note: Adjust field names ("Sprint", "Status", "Team") if they differ in your project
          csv_data=$(jq -r '
            .data.node.items.nodes | .[] | select(.content != null and .content.__typename == "Issue") | # Filter for actual issues
            [
              .content.number // "",
              .content.title // "",
              .content.state // "",
              .content.repository.nameWithOwner // "",
              .content.url // "",
              .content.createdAt // "",
              .content.updatedAt // "",
              .content.closedAt // "",
              .content.author.login // "",
              (.content.assignees.nodes | map(.login) | join(",")) // "", # Join assignees if multiple
              (.content.labels.nodes | map(.name) | join(",")) // "",    # Join labels if multiple
              .content.milestone.title // "",
              .content.issueType.name // "", # Keep this, will be populated if type is set
              .content.parent.number // "",
              .content.parent.title // "",
              # Extract Project Fields - use "? == field_name" for safety if field might not exist
              (.fieldValues.nodes | map(select(.field.name? == "Sprint")) | first | .title // ""),
              (.fieldValues.nodes | map(select(.field.name? == "Status")) | first | .name // ""),
              (.fieldValues.nodes | map(select(.field.name? == "Team")) | first | .name // "")
            ] | @csv # Format array as CSV row
          ' project_data.json)

          # Combine header and data, save to file
          output_file="${{ inputs.output_filename }}"
          echo "$header" > "$output_file"
          if [[ -n "$csv_data" ]]; then # Only add data if jq produced output
             echo "$csv_data" >> "$output_file"
          fi

          echo "CSV report generated: $output_file"
          echo "report_path=$output_file" >> $GITHUB_OUTPUT # Make path available to other steps

      - name: Upload CSV Report Artifact
        uses: actions/upload-artifact@v4
        with:
          name: project-issues-report # Name of the artifact zip file
          path: ${{ steps.generate_csv.outputs.report_path }} # Path to the generated CSV
